import path from 'node:path';
import { readFile, writeFile } from 'node:fs/promises';
import { MongoClient, ObjectId, Db } from 'mongodb';
import bcrypt from 'bcryptjs';
import { env } from '../src/config/env';

type PermissionSeed = {
  name: string;
  description?: string;
};

type RoleScope = 'system' | 'tenant';

type RoleSeed = {
  name: string;
  displayName: string;
  description?: string;
  permissions: string[];
  scope?: RoleScope;
};

type DesignationSeed = {
  name: string;
  description?: string;
};

type OrganisationSeed = {
  name: string;
  slug: string;
  status: string;
};

type UserSeed = {
  email: string;
  password?: string;
  passwordHash?: string;
  status: string;
  mobileNumber?: string;
  orgSlug?: string;
  role?: string;
  designation?: string;
};

type MasterDataSeed = {
  permissions: PermissionSeed[];
  roles: RoleSeed[];
  designations: DesignationSeed[];
  organisations: OrganisationSeed[];
  users: UserSeed[];
};

type PreparedShellUser = {
  email: string;
  passwordHash: string;
  status: string;
  mobileNumber?: string;
  orgSlug?: string;
  role?: string;
  designation?: string;
};

type ShellScriptData = {
  permissions: MasterDataSeed['permissions'];
  roles: MasterDataSeed['roles'];
  designations: MasterDataSeed['designations'];
  organisations: MasterDataSeed['organisations'];
  users: PreparedShellUser[];
};

const MASTER_DATA_PATH = path.resolve(__dirname, '../seed/master-data.json');
const MONGO_SHELL_SCRIPT_PATH = path.resolve(
  __dirname,
  '../seed/master-data.mongo.js'
);
const MONGO_SHELL_SCRIPT_TXT_PATH = path.resolve(
  __dirname,
  '../seed/master-data.mongo.txt'
);

const loadMasterData = async (): Promise<MasterDataSeed> => {
  const fileContent = await readFile(MASTER_DATA_PATH, 'utf-8');
  return JSON.parse(fileContent) as MasterDataSeed;
};

const ensureCollection = async (db: Db, name: string) => {
  const exists = await db
    .listCollections({ name }, { nameOnly: true })
    .hasNext();

  if (!exists) {
    await db.createCollection(name);
  }
};

const buildMongoShellScript = (
  data: ShellScriptData,
  dbName: string
): string => {
  const serialized = JSON.stringify(data, null, 2);
  const generatedAt = new Date().toISOString();
  return `// Auto-generated by seed-master-data.ts on ${generatedAt}
(function () {
  const dbRef = db.getSiblingDB('${dbName}');
  const now = new Date();
  const data = ${serialized};

  const ensureCollection = (name) => {
    if (dbRef.getCollectionInfos({ name }).length === 0) {
      dbRef.createCollection(name);
    }
  };

  ['permissions', 'roles', 'designations', 'tenants', 'users'].forEach(ensureCollection);

  data.permissions.forEach((permission) => {
    dbRef.permissions.updateOne(
      { name: permission.name },
      {
        $set: {
          description: permission.description || '',
          updatedAt: now
        },
        $setOnInsert: {
          name: permission.name,
          createdAt: now
        }
      },
      { upsert: true }
    );
  });

  data.roles.forEach((role) => {
    dbRef.roles.updateOne(
      { name: role.name },
      {
        $set: {
          displayName: role.displayName,
          description: role.description || '',
          permissions: role.permissions || [],
          scope: role.scope || 'tenant',
          updatedAt: now
        },
        $setOnInsert: {
          name: role.name,
          createdAt: now
        }
      },
      { upsert: true }
    );
  });

  data.designations.forEach((designation) => {
    dbRef.designations.updateOne(
      { name: designation.name },
      {
        $set: {
          name: designation.name,
          description: designation.description || '',
          updatedAt: now
        },
        $setOnInsert: {
          createdAt: now
        }
      },
      { upsert: true }
    );
  });

  data.organisations.forEach((organisation) => {
    dbRef.tenants.updateOne(
      { slug: organisation.slug },
      {
        $set: {
          name: organisation.name,
          slug: organisation.slug,
          status: organisation.status || 'active',
          updatedAt: now
        },
        $setOnInsert: {
          createdAt: now
        }
      },
      { upsert: true }
    );
  });

  data.users.forEach((user) => {
    const setDoc = {
      status: user.status,
      passwordHash: user.passwordHash,
      updatedAt: now
    };

    const unsetDoc = {};

    if (user.mobileNumber) {
      setDoc.mobileNumber = user.mobileNumber;
    } else {
      unsetDoc.mobileNumber = '';
    }

    if (user.orgSlug) {
      const organisation = dbRef.tenants.findOne({ slug: user.orgSlug });
      if (!organisation) {
        throw new Error('Organisation with slug ' + user.orgSlug + ' not found while seeding user ' + user.email);
      }
      setDoc.orgId = organisation._id;
    } else {
      unsetDoc.orgId = '';
    }

    if (user.role) {
      const roleDoc = dbRef.roles.findOne({ name: user.role });
      if (!roleDoc) {
        throw new Error('Role ' + user.role + ' not found while seeding user ' + user.email);
      }
      setDoc.roleId = roleDoc._id;
    } else {
      unsetDoc.roleId = '';
    }

    if (user.designation) {
      const designationDoc = dbRef.designations.findOne({ name: user.designation });
      if (!designationDoc) {
        throw new Error('Designation ' + user.designation + ' not found while seeding user ' + user.email);
      }
      setDoc.designationId = designationDoc._id;
    } else {
      unsetDoc.designationId = '';
    }

    const updateDoc = {
      $set: setDoc,
      $setOnInsert: {
        email: user.email,
        createdAt: now
      }
    };

    if (Object.keys(unsetDoc).length > 0) {
      updateDoc.$unset = unsetDoc;
    }

    dbRef.users.updateOne({ email: user.email }, updateDoc, { upsert: true });
  });

  print('Master data seeding completed via mongo shell script.');
})();
`;
};

const main = async () => {
  const masterData = await loadMasterData();
  const client = new MongoClient(env.MONGO_URI);
  await client.connect();

  const preparedShellUsers: PreparedShellUser[] = [];

  try {
    const db = client.db(env.MONGO_DB_NAME);

    await Promise.all([
      ensureCollection(db, 'permissions'),
      ensureCollection(db, 'roles'),
      ensureCollection(db, 'designations'),
      ensureCollection(db, 'tenants'),
      ensureCollection(db, 'users')
    ]);

    const permissionsCollection = db.collection('permissions');
    const rolesCollection = db.collection('roles');
    const designationsCollection = db.collection('designations');
    const organisationsCollection = db.collection('tenants');
    const usersCollection = db.collection('users');

    const now = new Date();

    console.log('Seeding permissions…');
    for (const permission of masterData.permissions) {
      await permissionsCollection.updateOne(
        { name: permission.name },
        {
          $set: {
            description: permission.description ?? '',
            updatedAt: now
          },
          $setOnInsert: {
            name: permission.name,
            createdAt: now
          }
        },
        { upsert: true }
      );
    }

    const roleMap = new Map<string, ObjectId>();
    console.log('Seeding roles…');
    for (const role of masterData.roles) {
      const result = await rolesCollection.findOneAndUpdate(
        { name: role.name },
        {
          $set: {
            displayName: role.displayName,
            description: role.description ?? '',
            permissions: role.permissions,
            scope: role.scope ?? 'tenant',
            updatedAt: now
          },
          $setOnInsert: {
            name: role.name,
            createdAt: now
          }
        },
        { upsert: true, returnDocument: 'after' }
      );

      if (!result || !result.value?._id) {
        throw new Error(`Failed to upsert role ${role.name}`);
      }

      roleMap.set(role.name, result.value._id as ObjectId);
    }

    const designationMap = new Map<string, ObjectId>();
    console.log('Seeding designations…');
    for (const designation of masterData.designations) {
      const result = await designationsCollection.findOneAndUpdate(
        { name: designation.name },
        {
          $set: {
            name: designation.name,
            description: designation.description ?? '',
            updatedAt: now
          },
          $setOnInsert: {
            createdAt: now
          }
        },
        { upsert: true, returnDocument: 'after' }
      );

      if (!result || !result.value?._id) {
        throw new Error(`Failed to upsert designation ${designation.name}`);
      }

      designationMap.set(designation.name, result.value._id as ObjectId);
    }

    const organisationMap = new Map<string, ObjectId>();
    console.log('Seeding organisations…');
    for (const organisation of masterData.organisations) {
      const result = await organisationsCollection.findOneAndUpdate(
        { slug: organisation.slug },
        {
          $set: {
            name: organisation.name,
            slug: organisation.slug,
            status: organisation.status,
            updatedAt: now
          },
          $setOnInsert: {
            createdAt: now
          }
        },
        { upsert: true, returnDocument: 'after' }
      );

      if (!result || !result.value?._id) {
        throw new Error(`Failed to upsert organisation ${organisation.slug}`);
      }

      organisationMap.set(organisation.slug, result.value._id as ObjectId);
    }

    console.log('Seeding users…');
    for (const user of masterData.users) {
      const existing = await usersCollection.findOne({ email: user.email });

      const orgId = user.orgSlug ? organisationMap.get(user.orgSlug) : undefined;
      if (user.orgSlug && !orgId) {
        throw new Error(
          `Organisation with slug ${user.orgSlug} not found for user ${user.email}`
        );
      }

      const roleId = user.role ? roleMap.get(user.role) : undefined;
      if (user.role && !roleId) {
        throw new Error(`Role ${user.role} not found for user ${user.email}`);
      }

      const designationId = user.designation
        ? designationMap.get(user.designation)
        : undefined;
      if (user.designation && !designationId) {
        throw new Error(
          `Designation ${user.designation} not found for user ${user.email}`
        );
      }

      let finalPasswordHash: string | undefined = user.passwordHash;

      if (user.password) {
        if (
          !existing ||
          !(await bcrypt.compare(user.password, existing.passwordHash))
        ) {
          finalPasswordHash = await bcrypt.hash(user.password, 12);
        } else {
          finalPasswordHash = existing.passwordHash;
        }
      } else if (!finalPasswordHash && existing) {
        finalPasswordHash = existing.passwordHash;
      }

      if (!finalPasswordHash) {
        throw new Error(
          `Password or passwordHash is required for user ${user.email}`
        );
      }

      const setDoc: Record<string, unknown> = {
        status: user.status,
        passwordHash: finalPasswordHash,
        updatedAt: now
      };

      const unsetDoc: Record<string, ''> = {};

      const applyReference = (
        field: 'orgId' | 'roleId' | 'designationId',
        value?: ObjectId
      ) => {
        if (value) {
          setDoc[field] = value;
        } else if (existing?.[field]) {
          unsetDoc[field] = '';
        }
      };

      applyReference('orgId', orgId);
      applyReference('roleId', roleId);
      applyReference('designationId', designationId);

      if (user.mobileNumber) {
        setDoc.mobileNumber = user.mobileNumber;
      } else if (existing?.mobileNumber) {
        unsetDoc.mobileNumber = '';
      }

      if (existing) {
        const updateDoc: Record<string, unknown> = {
          $set: setDoc
        };

        if (Object.keys(unsetDoc).length > 0) {
          updateDoc.$unset = unsetDoc;
        }

        await usersCollection.updateOne({ _id: existing._id }, updateDoc);
      } else {
        const insertDoc: Record<string, unknown> = {
          email: user.email,
          status: user.status,
          passwordHash: finalPasswordHash,
          createdAt: now,
          updatedAt: now
        };

        if (orgId) {
          insertDoc.orgId = orgId;
        }
        if (roleId) {
          insertDoc.roleId = roleId;
        }
        if (designationId) {
          insertDoc.designationId = designationId;
        }
        if (user.mobileNumber) {
          insertDoc.mobileNumber = user.mobileNumber;
        }

        await usersCollection.insertOne(insertDoc);
      }

      preparedShellUsers.push({
        email: user.email,
        passwordHash: finalPasswordHash,
        status: user.status,
        mobileNumber: user.mobileNumber,
        orgSlug: user.orgSlug,
        role: user.role,
        designation: user.designation
      });
    }

    const shellData: ShellScriptData = {
      permissions: masterData.permissions,
      roles: masterData.roles,
      designations: masterData.designations,
      organisations: masterData.organisations,
      users: preparedShellUsers
    };

    const shellScriptContents = buildMongoShellScript(
      shellData,
      env.MONGO_DB_NAME
    );
    await writeFile(MONGO_SHELL_SCRIPT_PATH, shellScriptContents, 'utf-8');
    await writeFile(MONGO_SHELL_SCRIPT_TXT_PATH, shellScriptContents, 'utf-8');
    console.log(`Mongo shell script generated at ${MONGO_SHELL_SCRIPT_PATH}`);
    console.log(`Mongo shell script (txt) generated at ${MONGO_SHELL_SCRIPT_TXT_PATH}`);

    console.log('Master data seeding completed successfully.');
  } finally {
    await client.close();
  }
};

main().catch((error) => {
  console.error('Failed to seed master data');
  console.error(error);
  process.exit(1);
});
